/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package mujoco.java;

import static org.junit.Assert.fail;

import java.io.File;
import java.util.HashMap;

import org.bytedeco.javacpp.BytePointer;
import org.bytedeco.javacpp.IntPointer;
import org.bytedeco.javacpp.Pointer;
import org.junit.Test;
import org.mujoco.IMujocoController;
import org.mujoco.MuJoCoLib;
import org.mujoco.MuJoCoLib.mjData;
import org.mujoco.MuJoCoLib.mjData_;
import org.mujoco.MuJoCoLib.mjModel;
import org.mujoco.MuJoCoLib.mjModel_;
import org.mujoco.MuJoCoLib.mjOption_;
import org.mujoco.MuJoCoLib.mjVFS;
import org.mujoco.MuJoCoModelManager;

public class MuJoColibTest {
	IMujocoController controller = (manager) -> {
		mjModel_ m=manager.getModel();
		mjData_ d=manager.getData();
		/**
		 * This illustrates two concepts. First, we are checking 
		 * if the number of controls mjModel.nu equals the number 
		 * of DoFs mjModel.nv. In general, the same callback may 
		 * be used with multiple models depending on how the user
		 *  code is structured, and so it is a good idea to check 
		 *  the model dimensions in the callback. Second, MuJoCo 
		 *  has a library of BLAS-like functions that are very 
		 *  useful; indeed a large part of the code base consists 
		 *  of calling such functions internally. The mju_scl 
		 *  function above scales the velocity vector mjData.qvel 
		 *  by a constant feedback gain and copies the result into 
		 *  the control vector mjData.ctrl.
		 */
		// apply controls
		// https://mujoco.readthedocs.io/en/stable/programming/simulation.html#simulation-loop
		
//		if (m.nu() == m.nv())
//			MuJoCoLib.mju_scl(d.ctrl(), d.qvel(), -0.1, m.nv());
		HashMap<String, Double> setEfforts = manager.getControlInstance();
		HashMap<String, Double> positions = manager.getAllJointPositions();
		// this is a simple P controller
		double target =0;
		double kp = 0.3;
		for(String s:manager.getActuatorNames()) {
			double error = target-positions.get(s);
			double effort = error * kp;
			System.out.println("Actuator "+s+" position "+positions.get(s)+" effort "+effort);
			setEfforts.put(s,effort);
		}
		manager.setActualtorCtrl(setEfforts);

	};

	@Test
	public void managerTest() throws InterruptedException {
		System.out.println("managerTest");
		String filename = "model/humanoid/humanoid.xml";
		File file = new File(filename);
		if (!file.exists()) {
			fail("File is missing from the disk");
		}
		MuJoCoModelManager m = new MuJoCoModelManager(file);
		System.out.println("Run ModelManager for 10 seconds");

		HashMap<String, Double> positions = m.getAllJointPositions();
		for(String s:m.getBodyNames()) {
			System.out.println("Body "+s+" pose "+m.getBodyPose(s));
		}
		for(String s:m.getJointNames()) {
			System.out.println("Joint  "+s+" position "+positions.get(s));
		}
		for(String s:m.getActuatorNames()) {
			System.out.println("Actuator "+s+" position "+positions.get(s));
		}
		for(String s:m.getGeometryNames()) {
			System.out.println("Geom "+s+" pose "+m.getGeometryPose(s)+" size "+m.getGeometrySize(s));
		}
		
		m.setController(controller);
		while (m.getCurrentSimulationTimeSeconds() < 10) {
			m.step();
			// sleep
			Thread.sleep(m.getTimestepMilliSeconds());
			for(String s:m.getBodyNames()) {
				System.out.println("Body "+s+" pose "+m.getBodyPose(s));
			}
		}
		m.close();
	}

	@Test
	public void mujocoJNILoadTest() {
		System.out.println("mujocoJNILoadTest");
		System.out.println(System.getProperty("org.bytedeco.javacpp.logger.debug"));
		System.setProperty("org.bytedeco.javacpp.logger.debug", "true");
		MuJoCoLib lib = new MuJoCoLib();

		System.out.println("Starting " + MuJoCoLib.mj_versionString().getString());

	}
}
